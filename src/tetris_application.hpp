#pragma once

#include "application.hpp"
#include "game_manager.hpp"
#include "network/network_manager.hpp"
#include "play_manager.hpp"
#include "settings.hpp"
#include "tetromino_type.hpp"
#include <cassert>
#include <cstdlib>
#include <exception>
#include <fstream>
#include <iostream>
#include <memory>
#include <spdlog/spdlog.h>
#include <utility>
#include <variant>

struct TetrisApplication : public Application {
private:
    static constexpr auto settings_filename = "settings.json";

    std::vector<std::unique_ptr<GameManager>> m_game_managers;
    std::vector<std::unique_ptr<Input>> m_inputs;
    Settings m_settings;

    std::unique_ptr<PlayManager> m_manager;

public:
    static constexpr int width = 1200;
    static constexpr int height = 600;

    explicit TetrisApplication(
            std::unique_ptr<PlayManager> manager,
            const tl::optional<std::filesystem::path>& recording_path
    )
        : Application{ "TetrisApplication", WindowPosition::Centered, width, height },
          m_manager{ std::move(manager) } {

        const auto settings = load_settings();
        if (settings.has_value()) {
            m_settings = *settings;
            spdlog::info("settings loaded");
        } else {
            spdlog::error("unable to load settings from \"{}\"", settings_filename);
            spdlog::warn("applying default settings");
        }

        //TODO assert that enough settings are here fro example 4 players! (could be more eventually!)

        const auto is_recording = recording_path.has_value();
        auto recording = [&]() -> tl::optional<Recording> {
            if (is_recording) {
                return Recording{ *recording_path };
            } else {
                return {};
            }
        }();

        //TODO the seed gets generated by the player manager, either by the client or the server in multiplayer scenarios

        //TODO: to handle recording support for multiplayer, we have to say in some way, which player is recorded, this has to be done with a custom PlayerManager, like ghostdata in Mario kart you can battle against a recorded data from yourself our from the cloud/ online ranking / leaderboard
        const auto random_seed = (is_recording ? recording->seed() : Random::generate_seed());

        auto is_valid = m_manager->init(m_settings, random_seed);
        if (!is_valid.has_value()) {
            std::cerr << "Error in initializing PlayManager: " << is_valid.error() << "\n";
            std::exit(2);
        }

        auto start_state = is_valid.value();
        const auto num_players = start_state.num_players;
        const auto seed_to_use = start_state.seed;

        for (std::size_t i = 0; i < num_players; ++i) {
            spdlog::info("seed for player {}: {}", i + 1, seed_to_use);
            //TODO get a more detailed start state from the client:
            //   m_game_managers.push_back(std::make_unique<GameManager>(i, start_state.state.at(i)));
            const auto record_game = not is_recording;
            //TODO get these from the manager, before calling get_input()!
            m_game_managers.push_back(std::make_unique<GameManager>(i, seed_to_use, record_game));
            if (is_recording) {
                m_inputs.push_back(create_input(ReplayControls{ std::move(*recording) }, m_game_managers.back().get()));
            } else {
                auto input_pair = m_manager->get_input(i, m_game_managers.back().get(), &m_event_dispatcher);
                m_game_managers.back().get()->set_player_num(input_pair.first);
                m_inputs.push_back(std::move(input_pair.second));
            }
        }


        for (const auto& game_manager : m_game_managers) {
            game_manager->spawn_next_tetromino();
        }

        //TODO if the window is to small to handle num_players, we have to resize in some way ,
        //TODO: if it's to big it has to be resized into an appropiate width
        [[maybe_unused]] const std::size_t game_field_size =
                (GameManager::size_per_field * num_players) + ((num_players - 1) * GameManager::space_between);


        //TODO: resize(), but then game_managers have to updated as well, to repaint or not?
    }


protected:
    void update() override {
        for (const auto& input : m_inputs) {
            input->update();
        }

        for (const auto& game_manager : m_game_managers) {
            game_manager->update();
        }
    }

    void render() const override {
        Application::render(); // call parent function to clear the screen
        for (const auto& game_manager : m_game_managers) {
            game_manager->render(*this);
        }
    }

private:
 std::unique_ptr<Input> create_input(Controls controls, GameManager* associated_game_manager) {
        return std::visit(
                overloaded{ [&](KeyboardControls& keyboard_controls) -> std::unique_ptr<Input> {
                               auto keyboard_input =
                                       std::make_unique<KeyboardInput>(associated_game_manager, keyboard_controls);
                               m_event_dispatcher.register_listener(keyboard_input.get());
                               return keyboard_input;
                           },
                            [&](ReplayControls& replay_controls) -> std::unique_ptr<Input> {
                                return std::make_unique<ReplayInput>(
                                        associated_game_manager, std::move(replay_controls.recording)
                                );
                            } },
                controls
        );
    }
    static tl::optional<Settings> load_settings() try {
        std::ifstream settings_file{ settings_filename };
        Settings settings = nlohmann::json::parse(settings_file);
        return settings;
    } catch (...) {
        return {};
    }
};
